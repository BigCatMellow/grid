<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', sans-serif; 
            background: #f5f5f0; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            min-height: 100vh;
            color: #555;
        }
        
        .container { 
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
        }
        
        /* Menu Button - Top Left */
        .menu-btn { 
            position: absolute; 
            top: -20px; 
            left: 0; 
            font-size: 12px; 
            color: #999; 
            cursor: pointer; 
            background: none; 
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            transition: all 0.15s;
        }
        .menu-btn:hover { color: #666; background: #e8e8e0; }
        
        /* Modal Menu */
        .menu-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.2);
            z-index: 99;
        }
        .menu-overlay.show { display: block; }
        
        .menu { 
            display: none;
            position: absolute; 
            top: -20px; 
            left: 0; 
            background: #fff; 
            border: 1px solid #ddd; 
            border-radius: 6px; 
            padding: 12px; 
            z-index: 100; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            min-width: 180px;
        }
        .menu.show { display: block; }
        
        .menu-close {
            position: absolute;
            top: -14px;
            left: 0;
            font-size: 12px;
            color: #999;
            cursor: pointer;
        }
        .menu-close:hover { color: #666; }
        
        .menu-section { 
            margin-bottom: 12px; 
            padding-bottom: 12px; 
            border-bottom: 1px solid #eee; 
        }
        .menu-section:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
        .menu-title { font-size: 9px; color: #999; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        
        .menu label { font-size: 10px; color: #888; display: block; margin-bottom: 4px; }
        .menu select, .menu input { 
            font-size: 11px; 
            padding: 6px 8px; 
            width: 100%; 
            margin-bottom: 8px; 
            background: #fafafa; 
            border: 1px solid #ddd; 
            color: #555; 
            border-radius: 4px;
            font-family: inherit;
        }
        .menu select:focus, .menu input:focus { outline: none; border-color: #aac; }
        
        .menu button { 
            font-size: 11px; 
            padding: 8px 10px; 
            width: 100%; 
            margin-bottom: 6px; 
            cursor: pointer; 
            background: #f5f5f0; 
            border: 1px solid #ddd; 
            color: #666; 
            border-radius: 4px;
            font-family: inherit;
            transition: all 0.15s;
        }
        .menu button:hover { background: #eee; border-color: #ccc; }
        .menu button:last-child { margin-bottom: 0; }
        
        .menu-row { display: flex; gap: 6px; }
        .menu-row button { flex: 1; min-width: 0; }
        
        /* The Grid */
        #grid { 
            display: grid; 
            grid-template-columns: repeat(9, 28px); 
            gap: 0; 
            background: #ccc; 
            border: 2px solid #999;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .cell { 
            width: 28px; 
            height: 28px; 
            border: 1px solid #ddd; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 14px; 
            cursor: pointer; 
            background: #fff; 
            color: #668; 
            user-select: none; 
            position: relative;
            transition: background 0.1s;
        }
        
        /* Box borders */
        .cell:nth-child(3n) { border-right-color: #999; }
        .cell:nth-child(9n+1) { border-left-color: #999; }
        .cell:nth-child(n+1):nth-child(-n+9) { border-top-color: #999; }
        .cell:nth-child(n+19):nth-child(-n+27) { border-bottom-color: #999; }
        .cell:nth-child(n+46):nth-child(-n+54) { border-bottom-color: #999; }
        .cell:nth-child(n+73):nth-child(-n+81) { border-bottom-color: #999; }
        
        /* Cell States - Muted Pastels */
        .cell.given { color: #445; font-weight: 600; }
        .cell.selected { background: #c9d4e8 !important; }
        .cell.multi-selected { background: #d4dce8 !important; }
        .cell.highlight-same { background: #e8d4c9; }
        .cell.highlight-related { background: #f0ece8; }
        .cell.conflict { background: #e8c9c9 !important; }
        .cell.error { background: #e0a8a8 !important; }
        .cell.correct-flash { background: #c9e8d4 !important; }
        .cell.possible-placement { background: #c9e8dc !important; }
        
        /* Pencil marks */
        .cell .pencil { 
            position: absolute; 
            top: 1px; 
            left: 1px; 
            right: 1px; 
            bottom: 1px; 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr);
            pointer-events: none;
        }
        .cell .pencil span { 
            font-size: 7px; 
            color: #8899aa; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            line-height: 1;
        }
        
        /* Bottom Action Bar - 3 Buttons Only */
        .action-bar {
            display: flex;
            gap: 4px;
            width: calc(9 * 28px + 4px); /* Match grid width including border */
            margin-top: 6px;
        }
        
        .action-btn {
            flex: 1;
            padding: 6px 0;
            font-size: 10px;
            font-family: inherit;
            background: #fff;
            border: 1px solid #ccc;
            color: #777;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .action-btn:hover { background: #f5f5f0; border-color: #bbb; color: #555; }
        .action-btn.active { 
            background: #d4dce8; 
            border-color: #a8b8c8; 
            color: #556;
        }
        
        /* Status bar */
        .status { 
            font-size: 9px; 
            color: #999; 
            text-align: center; 
            margin-top: 6px;
            display: flex;
            justify-content: space-between;
            width: calc(9 * 28px + 4px);
            padding: 0 4px;
        }
        .status span { min-width: 60px; }
        
        /* Selection count indicator */
        .selection-indicator {
            position: absolute;
            top: -20px;
            right: 0;
            font-size: 9px;
            color: #999;
            opacity: 0;
            transition: opacity 0.15s;
        }
        .selection-indicator.visible { opacity: 1; }
        
        /* Keyboard shortcuts hint */
        .shortcuts-hint {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #333;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="menu-btn" onclick="toggleMenu()">☰</button>
        <span class="selection-indicator" id="selectionIndicator"></span>
        
        <div class="menu-overlay" id="menuOverlay" onclick="toggleMenu()"></div>
        <div class="menu" id="menu">
            <span class="menu-close" onclick="toggleMenu()">☰</span>
            <div class="menu-section">
                <div class="menu-title">Puzzle</div>
                <label>Difficulty</label>
                <select id="diffSelect">
                    <option value="Beginner">Beginner</option>
                    <option value="Easy">Easy</option>
                    <option value="Medium" selected>Medium</option>
                    <option value="Hard">Hard</option>
                    <option value="Expert">Expert</option>
                </select>
                <button onclick="newGame()">New Puzzle</button>
                <button onclick="restartPuzzle()">Restart</button>
            </div>
            
            <div class="menu-section">
                <div class="menu-title">Options</div>
                <button id="autoCleanBtn" onclick="toggleAutoClean()">Auto-Clean Notes: ON</button>
                <button id="highlightBtn" onclick="toggleHighlight()">Highlighting: ON</button>
                <button id="conflictBtn" onclick="toggleConflicts()">Show Conflicts: ON</button>
                <button id="possibleBtn" onclick="togglePossiblePlacements()">Show Possible: OFF</button>
            </div>
            
            <div class="menu-section">
                <div class="menu-title">Seed</div>
                <input type="text" id="seedInput" placeholder="Enter seed...">
                <div class="menu-row">
                    <button onclick="loadSeed()">Load</button>
                    <button onclick="copySeed()">Copy</button>
                </div>
            </div>
        </div>
        
        <div id="grid"></div>
        
        <!-- Only 3 buttons below grid -->
        <div class="action-bar">
            <button class="action-btn" id="noteBtn" onclick="toggleNoteMode()">Notes</button>
            <button class="action-btn" onclick="undo()">Undo</button>
            <button class="action-btn" onclick="check()">Check</button>
        </div>
        
        <div class="status">
            <span id="statusLeft"></span>
            <span id="statusCenter"></span>
            <span id="statusRight"></span>
        </div>
    </div>

    <script>
        // =====================================================
        // 1. GAME STATE - Single Source of Truth
        // =====================================================
        const state = {
            board: [],
            solution: [],
            givenCells: new Set(),
            candidates: [],
            selected: new Set(),      // Multi-cell selection
            primaryCell: null,        // Primary selected cell for keyboard nav
            history: [],
            historyIndex: -1,
            
            // Settings
            difficulty: 'Medium',
            noteMode: false,
            lockedNumber: null,  // When notes mode is active, this is the number to add
            autoCleanNotes: true,
            showHighlighting: true,
            showConflicts: true,
            showPossiblePlacements: false,  // Show where a number can go when clicked
            autoCleanNotes: true,
            showHighlighting: true,
            showConflicts: true,
            
            // Puzzle metadata
            currentSeed: null,
            puzzleArchetype: null,
            techniquesRequired: []
        };
        
        // =====================================================
        // 2. PUZZLE GENERATION - Orchestrator Pattern
        // =====================================================
        
        // Archetypes define puzzle "flavor"
        const ARCHETYPES = {
            'pure-elimination': {
                name: 'Pure Elimination',
                requiredTechniques: ['nakedSingle', 'hiddenSingle'],
                forbiddenTechniques: ['nakedPair', 'hiddenPair', 'pointing', 'boxLine'],
                weight: { Beginner: 50, Easy: 40, Medium: 20, Hard: 5, Expert: 0 }
            },
            'structured': {
                name: 'Structured',
                requiredTechniques: ['nakedSingle', 'hiddenSingle'],
                allowedTechniques: ['pointing', 'boxLine'],
                weight: { Beginner: 30, Easy: 35, Medium: 30, Hard: 15, Expert: 5 }
            },
            'pattern-recognition': {
                name: 'Pattern Recognition',
                requiredTechniques: ['nakedPair', 'hiddenPair'],
                weight: { Beginner: 10, Easy: 15, Medium: 30, Hard: 35, Expert: 30 }
            },
            'advanced-logic': {
                name: 'Advanced Logic',
                requiredTechniques: ['nakedTriple', 'xWing'],
                weight: { Beginner: 0, Easy: 5, Medium: 15, Hard: 35, Expert: 50 }
            },
            'sparse': {
                name: 'Sparse Logic',
                minClues: 17,
                maxClues: 24,
                weight: { Beginner: 0, Easy: 0, Medium: 5, Hard: 10, Expert: 15 }
            }
        };
        
        // Difficulty settings
        const DIFFICULTY_SETTINGS = {
            'Beginner': { targetClues: 45, minClues: 42, maxAdvanced: 0 },
            'Easy':     { targetClues: 38, minClues: 35, maxAdvanced: 0 },
            'Medium':   { targetClues: 32, minClues: 28, maxAdvanced: 5 },
            'Hard':     { targetClues: 26, minClues: 23, maxAdvanced: 15 },
            'Expert':   { targetClues: 22, minClues: 17, maxAdvanced: 99 }
        };
        
        // Seeded random number generator
        let randState = 1;
        function seededRandom() { 
            randState |= 0; 
            randState = randState + 0x6D2B79F5 | 0; 
            let t = Math.imul(randState ^ randState >>> 15, 1 | randState); 
            t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t; 
            return ((t ^ t >>> 14) >>> 0) / 4294967296; 
        }
        function setSeed(seed) { 
            state.currentSeed = seed; 
            randState = seed; 
            document.getElementById('seedInput').value = seed; 
        }
        function generateSeed() { return Math.floor(Math.random() * 2147483647); }
        function shuffle(arr) { 
            const a = [...arr]; 
            for (let i = a.length - 1; i > 0; i--) { 
                const j = Math.floor(seededRandom() * (i + 1)); 
                [a[i], a[j]] = [a[j], a[i]]; 
            } 
            return a; 
        }
        
        // Select archetype based on difficulty weights
        function selectArchetype(difficulty) {
            const weights = [];
            let total = 0;
            for (const [key, arch] of Object.entries(ARCHETYPES)) {
                const w = arch.weight[difficulty] || 0;
                weights.push({ key, weight: w });
                total += w;
            }
            let r = seededRandom() * total;
            for (const { key, weight } of weights) {
                r -= weight;
                if (r <= 0) return key;
            }
            return 'pure-elimination';
        }
        
        // Check if placement is valid
        function isValidPlacement(board, row, col, num) {
            for (let i = 0; i < 9; i++) {
                if (board[row][i] === num || board[i][col] === num) return false;
            }
            const br = Math.floor(row / 3) * 3, bc = Math.floor(col / 3) * 3;
            for (let r = br; r < br + 3; r++) {
                for (let c = bc; c < bc + 3; c++) {
                    if (board[r][c] === num) return false;
                }
            }
            return true;
        }
        
        // Get possible values for a cell
        function getPossible(board, row, col) {
            const possible = [];
            for (let n = 1; n <= 9; n++) {
                if (isValidPlacement(board, row, col, n)) possible.push(n);
            }
            return possible;
        }
        
        // Count solutions (for uniqueness check)
        function countSolutions(board, limit = 2) {
            const copy = board.map(r => [...r]);
            let count = 0;
            
            function findBestEmpty() {
                let minCount = 10, best = null;
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (copy[r][c] === 0) {
                            let cnt = 0;
                            for (let n = 1; n <= 9; n++) {
                                if (isValidPlacement(copy, r, c, n)) cnt++;
                            }
                            if (cnt === 0) return null;
                            if (cnt < minCount) { minCount = cnt; best = [r, c]; }
                        }
                    }
                }
                return best;
            }
            
            function solve() {
                if (count >= limit) return;
                const cell = findBestEmpty();
                if (!cell) { count++; return; }
                const [r, c] = cell;
                for (let n = 1; n <= 9; n++) {
                    if (isValidPlacement(copy, r, c, n)) {
                        copy[r][c] = n;
                        solve();
                        copy[r][c] = 0;
                    }
                }
            }
            
            solve();
            return count;
        }
        
        // Generate complete valid board
        function generateCompleteBoard() {
            const board = Array(9).fill(null).map(() => Array(9).fill(0));
            
            // Fill diagonal boxes first (they don't affect each other)
            for (let box = 0; box < 3; box++) {
                const nums = shuffle([1,2,3,4,5,6,7,8,9]);
                const br = box * 3;
                for (let i = 0; i < 9; i++) {
                    board[br + Math.floor(i/3)][br + (i%3)] = nums[i];
                }
            }
            
            fillBoard(board);
            return board;
        }
        
        function fillBoard(board) {
            let minCount = 10, best = null;
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) {
                        const count = getPossible(board, r, c).length;
                        if (count < minCount) { minCount = count; best = [r, c]; }
                    }
                }
            }
            if (!best) return true;
            
            const [row, col] = best;
            for (const num of shuffle(getPossible(board, row, col))) {
                board[row][col] = num;
                if (fillBoard(board)) return true;
                board[row][col] = 0;
            }
            return false;
        }
        
        // Get symmetric cell pairs for aesthetic puzzles
        function getSymmetricPairs(symmetryType) {
            const pairs = [], seen = new Set();
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const key = `${r},${c}`;
                    if (seen.has(key)) continue;
                    let group = [[r, c]];
                    seen.add(key);
                    
                    if (symmetryType === 'rotational') {
                        const pr = 8 - r, pc = 8 - c, pk = `${pr},${pc}`;
                        if (!seen.has(pk)) { group.push([pr, pc]); seen.add(pk); }
                    } else if (symmetryType === 'mirror-h') {
                        const pc = 8 - c, pk = `${r},${pc}`;
                        if (!seen.has(pk)) { group.push([r, pc]); seen.add(pk); }
                    } else if (symmetryType === 'mirror-v') {
                        const pr = 8 - r, pk = `${pr},${c}`;
                        if (!seen.has(pk)) { group.push([pr, c]); seen.add(pk); }
                    } else if (symmetryType === 'diagonal') {
                        const pk = `${c},${r}`;
                        if (!seen.has(pk) && r !== c) { group.push([c, r]); seen.add(pk); }
                    }
                    pairs.push(group);
                }
            }
            return shuffle(pairs);
        }
        
        // =====================================================
        // 3. HUMAN-STYLE SOLVER (Technique Detection)
        // =====================================================
        
        function createCandidateGrid(board) {
            const cands = Array(9).fill(null).map(() => Array(9).fill(null).map(() => new Set()));
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) {
                        for (let n = 1; n <= 9; n++) {
                            if (isValidPlacement(board, r, c, n)) cands[r][c].add(n);
                        }
                    }
                }
            }
            return cands;
        }
        
        function analyzePuzzle(board) {
            const copy = board.map(r => [...r]);
            let cands = createCandidateGrid(copy);
            const techniquesUsed = new Set();
            let changed = true;
            let iterations = 0;
            const maxIterations = 100;
            
            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;
                
                // Naked Singles
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (copy[r][c] === 0 && cands[r][c].size === 1) {
                            const val = [...cands[r][c]][0];
                            copy[r][c] = val;
                            techniquesUsed.add('nakedSingle');
                            eliminateCandidate(cands, r, c, val);
                            cands[r][c].clear();
                            changed = true;
                        }
                    }
                }
                if (changed) continue;
                
                // Hidden Singles
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (copy[r][c] === 0) {
                            for (const num of cands[r][c]) {
                                // Check row
                                let uniqueInRow = true;
                                for (let cc = 0; cc < 9; cc++) {
                                    if (cc !== c && cands[r][cc].has(num)) { uniqueInRow = false; break; }
                                }
                                if (uniqueInRow) {
                                    copy[r][c] = num;
                                    techniquesUsed.add('hiddenSingle');
                                    eliminateCandidate(cands, r, c, num);
                                    cands[r][c].clear();
                                    changed = true;
                                    break;
                                }
                                
                                // Check column
                                let uniqueInCol = true;
                                for (let rr = 0; rr < 9; rr++) {
                                    if (rr !== r && cands[rr][c].has(num)) { uniqueInCol = false; break; }
                                }
                                if (uniqueInCol) {
                                    copy[r][c] = num;
                                    techniquesUsed.add('hiddenSingle');
                                    eliminateCandidate(cands, r, c, num);
                                    cands[r][c].clear();
                                    changed = true;
                                    break;
                                }
                                
                                // Check box
                                const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
                                let uniqueInBox = true;
                                for (let rr = br; rr < br+3; rr++) {
                                    for (let cc = bc; cc < bc+3; cc++) {
                                        if ((rr !== r || cc !== c) && cands[rr][cc].has(num)) {
                                            uniqueInBox = false; break;
                                        }
                                    }
                                    if (!uniqueInBox) break;
                                }
                                if (uniqueInBox) {
                                    copy[r][c] = num;
                                    techniquesUsed.add('hiddenSingle');
                                    eliminateCandidate(cands, r, c, num);
                                    cands[r][c].clear();
                                    changed = true;
                                    break;
                                }
                            }
                        }
                        if (changed) break;
                    }
                    if (changed) break;
                }
                if (changed) continue;
                
                // Naked Pairs
                if (findNakedPairs(cands)) {
                    techniquesUsed.add('nakedPair');
                    changed = true;
                    continue;
                }
                
                // Hidden Pairs
                if (findHiddenPairs(cands)) {
                    techniquesUsed.add('hiddenPair');
                    changed = true;
                    continue;
                }
                
                // Pointing Pairs/Triples
                if (findPointingPairs(cands)) {
                    techniquesUsed.add('pointing');
                    changed = true;
                    continue;
                }
                
                // Box/Line Reduction
                if (findBoxLineReduction(cands)) {
                    techniquesUsed.add('boxLine');
                    changed = true;
                    continue;
                }
            }
            
            // Count unsolved
            let unsolved = 0;
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (copy[r][c] === 0) unsolved++;
                }
            }
            
            return {
                solvable: unsolved === 0,
                techniquesUsed: [...techniquesUsed],
                unsolved,
                requiresGuessing: unsolved > 0
            };
        }
        
        function eliminateCandidate(cands, row, col, num) {
            // Row
            for (let c = 0; c < 9; c++) cands[row][c].delete(num);
            // Column
            for (let r = 0; r < 9; r++) cands[r][col].delete(num);
            // Box
            const br = Math.floor(row/3)*3, bc = Math.floor(col/3)*3;
            for (let r = br; r < br+3; r++) {
                for (let c = bc; c < bc+3; c++) {
                    cands[r][c].delete(num);
                }
            }
        }
        
        function findNakedPairs(cands) {
            // Check rows
            for (let r = 0; r < 9; r++) {
                const pairs = [];
                for (let c = 0; c < 9; c++) {
                    if (cands[r][c].size === 2) {
                        pairs.push({ col: c, nums: [...cands[r][c]] });
                    }
                }
                for (let i = 0; i < pairs.length; i++) {
                    for (let j = i + 1; j < pairs.length; j++) {
                        if (pairs[i].nums[0] === pairs[j].nums[0] && pairs[i].nums[1] === pairs[j].nums[1]) {
                            let eliminated = false;
                            for (let c = 0; c < 9; c++) {
                                if (c !== pairs[i].col && c !== pairs[j].col) {
                                    if (cands[r][c].delete(pairs[i].nums[0])) eliminated = true;
                                    if (cands[r][c].delete(pairs[i].nums[1])) eliminated = true;
                                }
                            }
                            if (eliminated) return true;
                        }
                    }
                }
            }
            
            // Check columns
            for (let c = 0; c < 9; c++) {
                const pairs = [];
                for (let r = 0; r < 9; r++) {
                    if (cands[r][c].size === 2) {
                        pairs.push({ row: r, nums: [...cands[r][c]] });
                    }
                }
                for (let i = 0; i < pairs.length; i++) {
                    for (let j = i + 1; j < pairs.length; j++) {
                        if (pairs[i].nums[0] === pairs[j].nums[0] && pairs[i].nums[1] === pairs[j].nums[1]) {
                            let eliminated = false;
                            for (let r = 0; r < 9; r++) {
                                if (r !== pairs[i].row && r !== pairs[j].row) {
                                    if (cands[r][c].delete(pairs[i].nums[0])) eliminated = true;
                                    if (cands[r][c].delete(pairs[i].nums[1])) eliminated = true;
                                }
                            }
                            if (eliminated) return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        function findHiddenPairs(cands) {
            // Simplified implementation - check rows for hidden pairs
            for (let r = 0; r < 9; r++) {
                for (let n1 = 1; n1 <= 8; n1++) {
                    for (let n2 = n1 + 1; n2 <= 9; n2++) {
                        const cols = [];
                        for (let c = 0; c < 9; c++) {
                            if (cands[r][c].has(n1) || cands[r][c].has(n2)) {
                                if (cands[r][c].has(n1) && cands[r][c].has(n2)) {
                                    cols.push(c);
                                } else if (cands[r][c].has(n1) || cands[r][c].has(n2)) {
                                    cols.push(-1); // Invalid
                                }
                            }
                        }
                        if (cols.length === 2 && cols[0] >= 0 && cols[1] >= 0) {
                            let eliminated = false;
                            for (const c of cols) {
                                for (const n of [...cands[r][c]]) {
                                    if (n !== n1 && n !== n2) {
                                        cands[r][c].delete(n);
                                        eliminated = true;
                                    }
                                }
                            }
                            if (eliminated) return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function findPointingPairs(cands) {
            for (let boxR = 0; boxR < 3; boxR++) {
                for (let boxC = 0; boxC < 3; boxC++) {
                    const br = boxR * 3, bc = boxC * 3;
                    for (let n = 1; n <= 9; n++) {
                        const positions = [];
                        for (let r = br; r < br + 3; r++) {
                            for (let c = bc; c < bc + 3; c++) {
                                if (cands[r][c].has(n)) positions.push([r, c]);
                            }
                        }
                        if (positions.length >= 2 && positions.length <= 3) {
                            // Check if all in same row
                            if (positions.every(p => p[0] === positions[0][0])) {
                                const row = positions[0][0];
                                let eliminated = false;
                                for (let c = 0; c < 9; c++) {
                                    if (c < bc || c >= bc + 3) {
                                        if (cands[row][c].delete(n)) eliminated = true;
                                    }
                                }
                                if (eliminated) return true;
                            }
                            // Check if all in same column
                            if (positions.every(p => p[1] === positions[0][1])) {
                                const col = positions[0][1];
                                let eliminated = false;
                                for (let r = 0; r < 9; r++) {
                                    if (r < br || r >= br + 3) {
                                        if (cands[r][col].delete(n)) eliminated = true;
                                    }
                                }
                                if (eliminated) return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        
        function findBoxLineReduction(cands) {
            // Check rows
            for (let r = 0; r < 9; r++) {
                for (let n = 1; n <= 9; n++) {
                    const cols = [];
                    for (let c = 0; c < 9; c++) {
                        if (cands[r][c].has(n)) cols.push(c);
                    }
                    if (cols.length >= 2 && cols.length <= 3) {
                        const boxC = Math.floor(cols[0] / 3);
                        if (cols.every(c => Math.floor(c / 3) === boxC)) {
                            const br = Math.floor(r / 3) * 3, bc = boxC * 3;
                            let eliminated = false;
                            for (let rr = br; rr < br + 3; rr++) {
                                if (rr !== r) {
                                    for (let cc = bc; cc < bc + 3; cc++) {
                                        if (cands[rr][cc].delete(n)) eliminated = true;
                                    }
                                }
                            }
                            if (eliminated) return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // =====================================================
        // 4. PUZZLE GENERATION ORCHESTRATOR
        // =====================================================
        
        function generatePuzzle(difficulty, seed) {
            setSeed(seed !== undefined ? seed : generateSeed());
            state.difficulty = difficulty;
            
            const settings = DIFFICULTY_SETTINGS[difficulty];
            const archetype = selectArchetype(difficulty);
            state.puzzleArchetype = archetype;
            
            // Generate solution
            state.solution = generateCompleteBoard();
            state.board = state.solution.map(r => [...r]);
            
            // Select symmetry style
            const symmetries = ['rotational', 'mirror-h', 'mirror-v', 'diagonal', 'random'];
            const symmetry = symmetries[Math.floor(seededRandom() * symmetries.length)];
            
            // Remove clues
            const pairs = symmetry === 'random' ? 
                shuffle(Array.from({length: 81}, (_, i) => [[Math.floor(i/9), i%9]])) :
                getSymmetricPairs(symmetry);
            
            let removed = 0;
            const targetRemove = 81 - settings.targetClues;
            
            for (const pair of pairs) {
                if (removed >= targetRemove) break;
                
                // Backup
                const backups = pair.map(([r, c]) => state.board[r][c]);
                
                // Try removing
                for (const [r, c] of pair) state.board[r][c] = 0;
                
                // Validate
                if (countSolutions(state.board) !== 1) {
                    // Revert - multiple solutions
                    for (let i = 0; i < pair.length; i++) {
                        state.board[pair[i][0]][pair[i][1]] = backups[i];
                    }
                    continue;
                }
                
                // Check if solvable without guessing (for easier difficulties)
                if (settings.maxAdvanced < 99) {
                    const analysis = analyzePuzzle(state.board);
                    if (analysis.requiresGuessing || analysis.unsolved > settings.maxAdvanced) {
                        // Revert - too hard
                        for (let i = 0; i < pair.length; i++) {
                            state.board[pair[i][0]][pair[i][1]] = backups[i];
                        }
                        continue;
                    }
                }
                
                removed += pair.length;
            }
            
            // Record given cells
            state.givenCells.clear();
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (state.board[r][c] !== 0) {
                        state.givenCells.add(`${r}-${c}`);
                    }
                }
            }
            
            // Analyze final puzzle
            const finalAnalysis = analyzePuzzle(state.board);
            state.techniquesRequired = finalAnalysis.techniquesUsed;
            
            // Initialize candidates
            initCandidates();
            
            // Clear history and selection
            state.history = [];
            state.historyIndex = -1;
            state.selected.clear();
            state.primaryCell = null;
        }
        
        function initCandidates() {
            state.candidates = Array(9).fill(null).map(() => 
                Array(9).fill(null).map(() => new Set())
            );
        }
        
        // =====================================================
        // 5. HISTORY SYSTEM (Grouped Undo)
        // =====================================================
        
        function saveHistory(description = '') {
            // Remove any future history if we're not at the end
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }
            
            // Save complete state snapshot
            state.history.push({
                board: state.board.map(r => [...r]),
                candidates: state.candidates.map(r => r.map(c => new Set(c))),
                description
            });
            
            state.historyIndex = state.history.length - 1;
            
            // Limit history size
            if (state.history.length > 100) {
                state.history.shift();
                state.historyIndex--;
            }
        }
        
        function undo() {
            if (state.historyIndex < 0) return;
            
            const snapshot = state.history[state.historyIndex];
            state.board = snapshot.board.map(r => [...r]);
            state.candidates = snapshot.candidates.map(r => r.map(c => new Set(c)));
            state.historyIndex--;
            
            render();
        }
        
        // =====================================================
        // 6. MULTI-CELL SELECTION
        // =====================================================
        
        function selectCell(row, col, additive = false) {
            const key = `${row}-${col}`;
            
            // If in note mode with a locked number, clicking empty cells adds the note
            if (state.noteMode && state.lockedNumber) {
                // Only work with empty, non-given cells
                if (!state.givenCells.has(key) && state.board[row][col] === 0) {
                    if (additive) {
                        // Shift-click: toggle this cell in selection and toggle the note
                        if (state.selected.has(key)) {
                            state.selected.delete(key);
                            // Remove the note
                            saveHistory(`Remove note ${state.lockedNumber}`);
                            state.candidates[row][col].delete(state.lockedNumber);
                        } else {
                            state.selected.add(key);
                            // Add the note
                            saveHistory(`Note ${state.lockedNumber}`);
                            state.candidates[row][col].add(state.lockedNumber);
                        }
                        state.primaryCell = key;
                    } else {
                        // Normal click: select this cell and toggle the note
                        state.selected.clear();
                        state.selected.add(key);
                        state.primaryCell = key;
                        
                        // Toggle the locked number as a note
                        saveHistory(`Note ${state.lockedNumber}`);
                        if (state.candidates[row][col].has(state.lockedNumber)) {
                            state.candidates[row][col].delete(state.lockedNumber);
                        } else {
                            state.candidates[row][col].add(state.lockedNumber);
                        }
                    }
                    updateSelectionIndicator();
                    render();
                    return;
                }
                // Clicking a filled cell while in locked note mode - switch to that number
                if (state.board[row][col] !== 0) {
                    state.lockedNumber = state.board[row][col];
                    state.selected.clear();
                    state.primaryCell = null;
                    render();
                    return;
                }
            }
            
            if (additive) {
                // Shift-click: toggle cell in selection
                if (state.selected.has(key)) {
                    state.selected.delete(key);
                    if (state.primaryCell === key) {
                        state.primaryCell = state.selected.size > 0 ? [...state.selected][0] : null;
                    }
                } else {
                    state.selected.add(key);
                    state.primaryCell = key;
                }
            } else {
                // Normal click: single selection
                state.selected.clear();
                state.selected.add(key);
                state.primaryCell = key;
            }
            
            updateSelectionIndicator();
            render();
        }
        
        function clearSelection() {
            state.selected.clear();
            state.primaryCell = null;
            updateSelectionIndicator();
            render();
        }
        
        function updateSelectionIndicator() {
            const indicator = document.getElementById('selectionIndicator');
            if (state.selected.size > 1) {
                indicator.textContent = `${state.selected.size} cells`;
                indicator.classList.add('visible');
            } else {
                indicator.classList.remove('visible');
            }
        }
        
        // =====================================================
        // 7. INPUT HANDLING (Batch Notes)
        // =====================================================
        
        function enterNumber(num) {
            if (state.selected.size === 0) return;
            
            // Filter to non-given cells
            const editableCells = [...state.selected].filter(key => !state.givenCells.has(key));
            if (editableCells.length === 0) return;
            
            saveHistory(state.noteMode ? `Note ${num}` : `Enter ${num}`);
            
            if (state.noteMode) {
                // Batch note entry
                for (const key of editableCells) {
                    const [r, c] = key.split('-').map(Number);
                    if (state.board[r][c] === 0) {
                        if (state.candidates[r][c].has(num)) {
                            state.candidates[r][c].delete(num);
                        } else {
                            state.candidates[r][c].add(num);
                        }
                    }
                }
            } else {
                // Value entry (single cell only for values)
                if (editableCells.length === 1 || state.selected.size === 1) {
                    const key = state.primaryCell || editableCells[0];
                    if (state.givenCells.has(key)) return;
                    
                    const [row, col] = key.split('-').map(Number);
                    state.board[row][col] = num;
                    state.candidates[row][col].clear();
                    
                    // Auto-clean notes if enabled
                    if (state.autoCleanNotes) {
                        cleanNotesFor(row, col, num);
                    }
                }
            }
            
            render();
        }
        
        function cleanNotesFor(row, col, num) {
            // Remove candidate from row
            for (let c = 0; c < 9; c++) state.candidates[row][c].delete(num);
            // Remove from column
            for (let r = 0; r < 9; r++) state.candidates[r][col].delete(num);
            // Remove from box
            const br = Math.floor(row/3)*3, bc = Math.floor(col/3)*3;
            for (let r = br; r < br+3; r++) {
                for (let c = bc; c < bc+3; c++) {
                    state.candidates[r][c].delete(num);
                }
            }
        }
        
        function clearSelectedCells() {
            const editableCells = [...state.selected].filter(key => !state.givenCells.has(key));
            if (editableCells.length === 0) return;
            
            saveHistory('Clear');
            
            for (const key of editableCells) {
                const [r, c] = key.split('-').map(Number);
                state.board[r][c] = 0;
                state.candidates[r][c].clear();
            }
            
            render();
        }
        
        // =====================================================
        // 8. RENDERING
        // =====================================================
        
        function render() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    const key = `${row}-${col}`;
                    const val = state.board[row][col];
                    
                    // Value or pencil marks
                    if (val !== 0) {
                        cell.textContent = val;
                        if (state.givenCells.has(key)) {
                            cell.classList.add('given');
                        }
                    } else if (state.candidates[row][col].size > 0) {
                        const pencil = document.createElement('div');
                        pencil.className = 'pencil';
                        for (let n = 1; n <= 9; n++) {
                            const span = document.createElement('span');
                            span.textContent = state.candidates[row][col].has(n) ? n : '';
                            pencil.appendChild(span);
                        }
                        cell.appendChild(pencil);
                    }
                    
                    // Selection states
                    if (state.primaryCell === key) {
                        cell.classList.add('selected');
                    } else if (state.selected.has(key)) {
                        cell.classList.add('multi-selected');
                    }
                    
                    // Mouse events
                    cell.addEventListener('click', (e) => {
                        selectCell(row, col, e.shiftKey);
                    });
                    
                    cell.addEventListener('dblclick', () => {
                        if (!state.givenCells.has(key) && state.board[row][col] !== 0) {
                            saveHistory('Clear');
                            state.board[row][col] = 0;
                            render();
                        }
                    });
                    
                    grid.appendChild(cell);
                }
            }
            
            // Apply highlighting
            if (state.showHighlighting) {
                if (state.noteMode && state.lockedNumber) {
                    // Highlight all cells with the locked number
                    highlightLockedNumber();
                } else if (state.primaryCell) {
                    highlightRelated();
                }
            }
            
            // Check conflicts
            if (state.showConflicts) {
                checkConflicts();
            }
            
            // Apply possible placements (after conflicts so it doesn't get cleared)
            if (state.showPossiblePlacements && state.primaryCell && !state.noteMode) {
                const [row, col] = state.primaryCell.split('-').map(Number);
                const val = state.board[row][col];
                if (val !== 0) {
                    highlightPossiblePlacements(val);
                }
            } else if (state.showPossiblePlacements && state.noteMode && state.lockedNumber) {
                highlightPossiblePlacements(state.lockedNumber);
            }
            
            updateStatus();
        }
        
        function highlightRelated() {
            if (!state.primaryCell) return;
            
            const [row, col] = state.primaryCell.split('-').map(Number);
            const val = state.board[row][col];
            const br = Math.floor(row/3)*3, bc = Math.floor(col/3)*3;
            
            document.querySelectorAll('.cell').forEach(cell => {
                const r = +cell.dataset.row, c = +cell.dataset.col;
                const key = `${r}-${c}`;
                
                if (state.selected.has(key)) return;
                
                // Highlight same number
                if (val !== 0 && state.board[r][c] === val) {
                    cell.classList.add('highlight-same');
                }
                // Highlight related cells (row, column, box)
                else if (r === row || c === col || 
                    (r >= br && r < br+3 && c >= bc && c < bc+3)) {
                    cell.classList.add('highlight-related');
                }
            });
        }
        
        function highlightPossiblePlacements(num) {
            document.querySelectorAll('.cell').forEach(cell => {
                const r = +cell.dataset.row, c = +cell.dataset.col;
                
                // Only check empty cells
                if (state.board[r][c] === 0) {
                    // Check if this number can go here
                    if (isValidPlacement(state.board, r, c, num)) {
                        cell.classList.add('possible-placement');
                    }
                }
            });
        }
        
        function highlightLockedNumber() {
            const num = state.lockedNumber;
            document.querySelectorAll('.cell').forEach(cell => {
                const r = +cell.dataset.row, c = +cell.dataset.col;
                const key = `${r}-${c}`;
                
                if (state.selected.has(key)) return;
                
                // Highlight all cells containing the locked number
                if (state.board[r][c] === num) {
                    cell.classList.add('highlight-same');
                }
                // Also subtly highlight cells that have this number as a candidate
                else if (state.candidates[r][c].has(num)) {
                    cell.classList.add('highlight-related');
                }
            });
        }
        
        function checkConflicts() {
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('conflict'));
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const val = state.board[row][col];
                    if (!val) continue;
                    
                    // Check row
                    for (let c = 0; c < 9; c++) {
                        if (c !== col && state.board[row][c] === val) {
                            markConflict(row, col);
                            markConflict(row, c);
                        }
                    }
                    // Check column
                    for (let r = 0; r < 9; r++) {
                        if (r !== row && state.board[r][col] === val) {
                            markConflict(row, col);
                            markConflict(r, col);
                        }
                    }
                    // Check box
                    const br = Math.floor(row/3)*3, bc = Math.floor(col/3)*3;
                    for (let r = br; r < br+3; r++) {
                        for (let c = bc; c < bc+3; c++) {
                            if ((r !== row || c !== col) && state.board[r][c] === val) {
                                markConflict(row, col);
                                markConflict(r, c);
                            }
                        }
                    }
                }
            }
        }
        
        function markConflict(row, col) {
            document.querySelector(`[data-row="${row}"][data-col="${col}"]`)?.classList.add('conflict');
        }
        
        function updateStatus() {
            let empty = 0;
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (state.board[r][c] === 0) empty++;
                }
            }
            
            document.getElementById('statusLeft').textContent = state.difficulty;
            document.getElementById('statusCenter').textContent = empty > 0 ? `${empty} left` : '✓';
            document.getElementById('statusRight').textContent = ARCHETYPES[state.puzzleArchetype]?.name || '';
        }
        
        // =====================================================
        // 9. UI CONTROLS
        // =====================================================
        
        function toggleNoteMode() {
            state.noteMode = !state.noteMode;
            
            if (state.noteMode && state.primaryCell) {
                // Lock the number from the currently selected cell
                const [r, c] = state.primaryCell.split('-').map(Number);
                const val = state.board[r][c];
                if (val !== 0) {
                    state.lockedNumber = val;
                    // Clear selection so user can start selecting empty cells
                    state.selected.clear();
                    state.primaryCell = null;
                } else {
                    state.lockedNumber = null;
                }
            } else {
                state.lockedNumber = null;
            }
            
            document.getElementById('noteBtn').classList.toggle('active', state.noteMode);
            render();
        }
        
        function toggleMenu() {
            const menu = document.getElementById('menu');
            const overlay = document.getElementById('menuOverlay');
            menu.classList.toggle('show');
            overlay.classList.toggle('show');
        }
        
        function toggleAutoClean() {
            state.autoCleanNotes = !state.autoCleanNotes;
            document.getElementById('autoCleanBtn').textContent = 
                `Auto-Clean Notes: ${state.autoCleanNotes ? 'ON' : 'OFF'}`;
        }
        
        function toggleHighlight() {
            state.showHighlighting = !state.showHighlighting;
            document.getElementById('highlightBtn').textContent = 
                `Highlighting: ${state.showHighlighting ? 'ON' : 'OFF'}`;
            render();
        }
        
        function toggleConflicts() {
            state.showConflicts = !state.showConflicts;
            document.getElementById('conflictBtn').textContent = 
                `Show Conflicts: ${state.showConflicts ? 'ON' : 'OFF'}`;
            render();
        }
        
        function togglePossiblePlacements() {
            // Not available on Expert
            if (state.difficulty === 'Expert') return;
            
            state.showPossiblePlacements = !state.showPossiblePlacements;
            updatePossiblePlacementsButton();
            render();
        }
        
        function updatePossiblePlacementsButton() {
            const btn = document.getElementById('possibleBtn');
            if (state.difficulty === 'Expert') {
                btn.textContent = 'Show Possible: N/A';
                btn.disabled = true;
                btn.style.opacity = '0.5';
            } else {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.textContent = `Show Possible: ${state.showPossiblePlacements ? 'ON' : 'OFF'}`;
            }
        }
        
        function applyDifficultySettings() {
            // Auto-enable for Beginner and Easy
            if (state.difficulty === 'Beginner' || state.difficulty === 'Easy') {
                state.showPossiblePlacements = true;
            } else if (state.difficulty === 'Expert') {
                state.showPossiblePlacements = false;
            }
            // Medium and Hard keep current setting (default off)
            updatePossiblePlacementsButton();
        }
        
        function check() {
            document.querySelectorAll('.cell').forEach(c => {
                c.classList.remove('error', 'correct-flash');
            });
            
            let allCorrect = true;
            let hasErrors = false;
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const val = state.board[row][col];
                    if (val === 0) {
                        allCorrect = false;
                    } else if (val !== state.solution[row][col]) {
                        document.querySelector(`[data-row="${row}"][data-col="${col}"]`).classList.add('error');
                        allCorrect = false;
                        hasErrors = true;
                    }
                }
            }
            
            if (allCorrect) {
                // Subtle completion effect
                document.querySelectorAll('.cell').forEach((c, i) => {
                    setTimeout(() => c.classList.add('correct-flash'), i * 10);
                });
            }
        }
        
        function newGame() {
            const difficulty = document.getElementById('diffSelect').value;
            generatePuzzle(difficulty);
            applyDifficultySettings();
            render();
            toggleMenu();
        }
        
        function restartPuzzle() {
            // Reset board to given cells only
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (!state.givenCells.has(`${r}-${c}`)) {
                        state.board[r][c] = 0;
                    }
                }
            }
            initCandidates();
            state.history = [];
            state.historyIndex = -1;
            state.selected.clear();
            state.primaryCell = null;
            render();
            toggleMenu();
        }
        
        function loadSeed() {
            const seed = parseInt(document.getElementById('seedInput').value);
            if (!isNaN(seed)) {
                const difficulty = document.getElementById('diffSelect').value;
                generatePuzzle(difficulty, seed);
                render();
                toggleMenu();
            }
        }
        
        function copySeed() {
            navigator.clipboard.writeText(state.currentSeed.toString());
        }
        
        // =====================================================
        // 10. KEYBOARD HANDLING
        // =====================================================
        
        document.addEventListener('keydown', (e) => {
            // Toggle notes
            if (e.key === 'n' || e.key === 'N') {
                if (!e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    toggleNoteMode();
                    return;
                }
            }
            
            // Number keys 1-9 to change locked number in note mode
            if (state.noteMode && state.lockedNumber && e.key >= '1' && e.key <= '9') {
                state.lockedNumber = parseInt(e.key);
                render();
                return;
            }
            
            // Close menu
            if (e.key === 'Escape') {
                if (document.getElementById('menu').classList.contains('show')) {
                    toggleMenu();
                } else {
                    clearSelection();
                }
                return;
            }
            
            // Undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
                return;
            }
            
            // Navigation
            if (state.primaryCell) {
                const [row, col] = state.primaryCell.split('-').map(Number);
                
                if (e.key === 'ArrowUp' && row > 0) {
                    e.preventDefault();
                    selectCell(row - 1, col, e.shiftKey);
                    return;
                }
                if (e.key === 'ArrowDown' && row < 8) {
                    e.preventDefault();
                    selectCell(row + 1, col, e.shiftKey);
                    return;
                }
                if (e.key === 'ArrowLeft' && col > 0) {
                    e.preventDefault();
                    selectCell(row, col - 1, e.shiftKey);
                    return;
                }
                if (e.key === 'ArrowRight' && col < 8) {
                    e.preventDefault();
                    selectCell(row, col + 1, e.shiftKey);
                    return;
                }
            }
            
            // Number entry
            if (e.key >= '1' && e.key <= '9') {
                enterNumber(parseInt(e.key));
            } else if (e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') {
                clearSelectedCells();
            }
        });
        
        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.menu') && 
                !e.target.closest('.menu-btn') && 
                !e.target.closest('#grid')) {
                if (document.getElementById('menu').classList.contains('show')) {
                    toggleMenu();
                }
            }
        });
        
        // =====================================================
        // 11. INITIALIZATION
        // =====================================================
        
        generatePuzzle('Medium');
        applyDifficultySettings();
        render();
    </script>
</body>
</html>
